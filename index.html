<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Control de Velocidad Doble - Moto</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Courier New', monospace;
    }

    body {
      background: #0a0a12;
      color: white;
      height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      overflow: hidden;
      padding: 20px;
    }

    .tachometer {
      width: 90vw;
      max-width: 400px;
      background: radial-gradient(circle, #1a1a2e 0%, #0d0d1a 100%);
      border-radius: 20px;
      padding: 25px;
      box-shadow: 0 0 20px rgba(0, 200, 255, 0.3),
                  inset 0 0 15px rgba(0, 0, 0, 0.8);
      border: 2px solid #333;
      position: relative;
    }

    .tachometer::before {
      content: "";
      position: absolute;
      top: -5px;
      left: -5px;
      right: -5px;
      bottom: -5px;
      border-radius: 25px;
      background: linear-gradient(135deg, #003366, #001122);
      z-index: -1;
    }

    h1 {
      text-align: center;
      font-size: 18px;
      margin-bottom: 20px;
      color: #4fc3f7;
      text-shadow: 0 0 8px rgba(79, 195, 247, 0.6);
    }

    .speed-panel {
      display: flex;
      justify-content: space-between;
      margin: 20px 0;
    }

    .speed-box {
      text-align: center;
      flex: 1;
      padding: 10px;
    }

    .label {
      font-size: 14px;
      margin-bottom: 8px;
      opacity: 0.8;
    }

    .gps .label {
      color: #4caf50;
    }

    .sensor .label {
      color: #29b6f6;
    }

    .speed-value {
      font-size: 56px;
      font-weight: bold;
      line-height: 1;
      text-shadow: 0 0 10px currentColor;
      font-family: 'Courier New', monospace;
    }

    .gps .speed-value {
      color: #66bb6a;
    }

    .sensor .speed-value {
      color: #4fc3f7;
    }

    .delta {
      text-align: center;
      margin-top: 10px;
      font-size: 16px;
      color: #ffcc00;
    }

    .status {
      display: flex;
      justify-content: space-around;
      margin-top: 15px;
      font-size: 14px;
      opacity: 0.7;
    }

    .unit {
      font-size: 18px;
      position: absolute;
      right: 25px;
      top: 45px;
      color: #aaa;
    }
  </style>
</head>
<body>

<div class="tachometer">
  <h1>CONTROL DE VELOCIDAD DOBLE v1</h1>
  
  <div class="speed-panel">
    <div class="speed-box gps">
      <div class="label">GPS (Sat茅lite)</div>
      <div class="speed-value" id="gpsSpeed">--</div>
    </div>
    <div class="speed-box sensor">
      <div class="label">Sensor (Inercial)</div>
      <div class="speed-value" id="sensorSpeed">--</div>
    </div>
  </div>

  <div class="delta" id="delta"> = -- km/h</div>

  <div class="status">
    <span id="gpsStatus"> Esperando GPS</span>
    <span id="sensorStatus">Л Sensores activos</span>
  </div>

  <div class="unit">km/h</div>
</div>

<script>
  // Elementos del DOM
  const gpsSpeedEl = document.getElementById('gpsSpeed');
  const sensorSpeedEl = document.getElementById('sensorSpeed');
  const deltaEl = document.getElementById('delta');
  const gpsStatusEl = document.getElementById('gpsStatus');
  const sensorStatusEl = document.getElementById('sensorStatus');

  // Variables para velocidad
  let gpsSpeed = 0; // en km/h
  let sensorSpeed = 0; // estimado en km/h
  let lastTime = 0;
  let lastVelocity = 0; // para integraci贸n del aceler贸metro

  // === GPS ===
  if ("geolocation" in navigator) {
    navigator.geolocation.watchPosition(
      (position) => {
        gpsSpeed = position.coords.speed ? Math.round(position.coords.speed * 3.6) : 0;
        gpsSpeedEl.textContent = gpsSpeed;
        gpsStatusEl.textContent = " GPS OK";
        updateDelta();
      },
      (error) => {
        gpsStatusEl.textContent = " Sin se帽al";
        gpsSpeed = 0;
        gpsSpeedEl.textContent = "--";
      },
      {
        enableHighAccuracy: true,
        timeout: 10000,
        maximumAge: 0
      }
    );
  } else {
    gpsStatusEl.textContent = " No soportado";
  }

  // === Sensores Inerciales (Aceler贸metro + Giroscopio) ===
  let accelerationX = 0, accelerationY = 0, accelerationZ = 0;
  let gravity = [0, 0, 9.81]; // estimaci贸n inicial de gravedad

  // Filtro para separar gravedad de aceleraci贸n lineal (filtro complementario simple)
  const alpha = 0.8;

  window.addEventListener('deviceorientation', (event) => {
    // Solo usamos aceler贸metro si est谩 disponible
  });

  if (typeof DeviceMotionEvent !== 'undefined' && 'requestPermission' in DeviceMotionEvent) {
    // iOS 13+
    DeviceMotionEvent.requestPermission()
      .then(permissionState => {
        if (permissionState === 'granted') {
          window.addEventListener('devicemotion', handleMotion);
          sensorStatusEl.textContent = "Л Sensores OK";
        }
      })
      .catch(console.error);
  } else if (typeof DeviceMotionEvent !== 'undefined') {
    // Android y otros
    window.addEventListener('devicemotion', handleMotion);
    sensorStatusEl.textContent = "Л Sensores OK";
  } else {
    sensorStatusEl.textContent = "Л No soportado";
  }

  function handleMotion(event) {
    const acc = event.accelerationIncludingGravity;
    if (!acc) return;

    // Estimaci贸n simple de gravedad (promedio m贸vil)
    gravity[0] = alpha * gravity[0] + (1 - alpha) * acc.x;
    gravity[1] = alpha * gravity[1] + (1 - alpha) * acc.y;
    gravity[2] = alpha * gravity[2] + (1 - alpha) * acc.z;

    // Aceleraci贸n lineal (sin gravedad)
    const linearAccX = acc.x - gravity[0];
    const linearAccY = acc.y - gravity[1];
    const linearAccZ = acc.z - gravity[2];

    // Proyectamos en direcci贸n de movimiento (simplificamos a eje X)
    const linearAcc = linearAccX;

    // Integraci贸n para velocidad (m/s)
    const now = performance.now();
    if (lastTime === 0) {
      lastTime = now;
      return;
    }
    const dt = (now - lastTime) / 1000; // segundos
    lastVelocity += linearAcc * dt; // v = v0 + a*t

    // Peque帽o decaimiento para evitar deriva infinita
    lastVelocity *= 0.98;

    // Convertir a km/h y limitar ruido
    sensorSpeed = Math.abs(lastVelocity * 3.6);
    if (sensorSpeed < 2) sensorSpeed = 0; // ruido bajo
    sensorSpeed = Math.round(sensorSpeed);

    sensorSpeedEl.textContent = sensorSpeed;
    lastTime = now;
    updateDelta();
  }

  function updateDelta() {
    const diff = Math.abs(gpsSpeed - sensorSpeed);
    deltaEl.textContent = ` = ${diff} km/h`;
  }

  // Fallback: si no hay sensores, usar GPS en ambos (solo para visualizaci贸n)
  setInterval(() => {
    if (sensorSpeedEl.textContent === "--" && gpsSpeedEl.textContent !== "--") {
      sensorSpeedEl.textContent = gpsSpeedEl.textContent;
      deltaEl.textContent = " = 0 km/h";
    }
  }, 2000);
</script>

</body>
</html>
